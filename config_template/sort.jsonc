{
	/* Wether to sort torrents or not - All other settings are ignored if disabled
	Sorting is useful when many torrents are active at the same stage. For example when many torrents are downloading or in a checking state.
	If prioritising active downloads, ensure torrent queuing is enabled in qbittorrent, otherwise these settings will have no effect.
	*/
	"SORT": true,

	/* Check position right after move and keep moving until in correct position
	Moves will be a lot slower, but ensures higher priority torrents are in the correct position sooner.
	*/
	"PERSISTENT_MOVES": false,

	/* Time to wait before sorting each individual torrent
	Setting too fast may cause race conditions in qBittorrent or even make it unresponsive or crash.
	
	If "do not count slow torrents" is enabled in qBittorrent, ensure the move delay is faster than the time it takes to process slow torrents.
	For example, if you are processing 10 torrents at a time, and you've configured to ignore slow torrents after 60 seconds of inactivity, ensure the move delay is less than 6000ms (60 seconds / 10 torrents).
	Failing to do so will result in qBittorrent downloading torrents in the wrong order.
	
	Set to 0 to disable delay - Will consume more CPU and may cause issues in qBittorrent.
	*/
	"MOVE_DELAY": 100,

	/* Maximum number of torrents to move each cycle
	Once this threshold is reached, the sorter will wait for the move delay before running again.
	When managing a large number of torrents, this is particularly useful as it focuses on sorting the first X torrents, then moves onto the next X torrents in the next cycle.
	The lower this number is, the more you want accurate ordering for earlier torrents.
	For example, if you have 1000 torrents, and you set this to 10, it will sort the first 10 torrents, then re-check positioning, then sort the next 10 torrents that need to be moved.

	Lower this number to increase the "refresh rate" of the sorter, lower numbers result in top torrents being moved up first.

	Set to 0 to disable stepping.
	*/
	"RESORT_STEP": 250,

	/* Minimum API calls to make before stopping when using RESORT_STEP
	This ensures that if you have too many redundant moves at the start of your queue, it will still send a minimum number of API calls before stopping.
	*/
	"RESORT_STEP_MINIMUM_CALLS": 5,

	/* Maximum number of API calls to make when sorting torrents each cycle
	Works exactly like RESORT_STEP, but ignores redundant moves in the count.
	RESORT_STEP and RESORT_STEP_API can work both together or independently.

	Set to 0 to disable stepping.
	*/
	"RESORT_STEP_CALLS": 100,

	/*
	Sorts are applied in reverse order, with last being highest priority
	For example, if you want to prefer private torrents over finishing ones, put PRIVATE after amount_left
	This will order all private torrents first, then sort by amount_left within that group

	Examples:
	Prioritize season premieres and private trackers:
	[
		{"key": "SIZE", "type": "ASC"},
		{"key": "NAME_CONTAINS", "type": "DESC", "searchString": "S01"},
		{"key": "PRIVATE", "type": "DESC"}
	]
	Finish downloads that are closest to completion:
	[
		{"key": "amount_left", "type": "ASC"},
		{"key": "PROGRESS", "type": "DESC"}
	]
	Prioritize specific private trackers (Use [qBit Manage](https://github.com/StuffAnThings/qbit_manage) to tag trackers):
	[
		{"key": "PRIVATE", "type": "DESC"},
		{"key": "TAGS", "type": "ASC", "tags": ["@MaM", "@TL"]},
		{"key": "TAGS", "type": "ASC", "tags": ["@PTP", "@BTN"]}
	]
	*/
	"METHODS": [
		/* Prefer smaller torrents
		ASC: Smallest first
		DESC: Largest first
		*/
		{"key": "size", "type": "ASC"},
		/* Prefer torrents with the most progress
		ASC: Least progress first
		DESC: Most progress first
		*/
		{"key": "progress", "type": "DESC"},
		/* Prefer torrents with the most completed data
		ASC: Least completed first
		DESC: Most completed first
		*/
		{"key": "completed", "type": "DESC"},
		/* Prefer torrents closest to completion
		ASC: Closest to finishing first
		DESC: Furthest from finishing first - This is useful if you want to prioritise starting new torrents over finishing existing ones
		*/
		{"key": "amount_left", "type": "ASC"},
		/* Prefer finishing private torrents
		ASC: Non-private first
		DESC: Private first
		*/
		{"key": "private", "type": "IS"},
		/* Prefer torrents with specific tags
		ASC: Without tags first
		DESC: With tags first
		When specifying multiple tags, the order of tags does not matter. If you want to prioritise specific tags over others, use multiple sort entries.
		*/
		// { "key": "TAGS", "type": "DESC", "tags": ["@DP"] },
		// { "key": "TAGS", "type": "DESC", "tags": ["@MaM"] },
		/* Prefer finishing torrents whose name contains a specific string
		ASC: Contains last
		DESC: Contains first
		*/
		{"key": "name", "type": "IS", "includes": ["S01"]},
		/* Prefer torrents in specific categories
		ASC: Without categories first
		DESC: With categories first
		When specifying multiple categories, the order of categories does not matter. If you want to prioritise specific categories over others, use multiple sort entries.
		*/
		{"key": "category", "type": "IS", "includes": ["cross-seed-links"]},
		/* Prefer torrents that are almost finished
		ASC: Almost finished last
		DESC: Almost finished first
		Threshold is a float between 0 and 1, representing the progress percentage.
		*/
		{"key": "progress", "type": "IS", "threshold": 0.1},
		{"key": "progress", "type": "IS", "threshold": 0.99},
		/* Prefer manually prioritised torrents
		ASC: Priority 1 first
		DESC: Priority 1 last
		Untagged torrents are considered priority 50
		*/
		// {"key": "PRIORITY_TAG", "type": "ASC", "prefix": "Priority - "}, // TODO: // Tag torrents with "Priority - 1", "Priority - 2", ..., "Priority - 100" to set their priority
		/* Prefer torrents without metadata
		ASC: Torrents with metadata first
		DESC: Torrents without metadata first
		By default, torrents without metadata are de-prioritised as they can't accurately be sorted by size or progress.
		It is recommended to leave this as-is, and let Metadatarr source torrents instead of qBittorrent.
		*/
		{"key": "state", "type": "IS NOT", "includes": ["stoppedDL", "stoppedUP"]},
		{"key": "size", "type": "IS NOT", "threshold": 0}
	],
	/*
	Custom sort rules for torrents in a checking state
	Checking torrents are only sorted amongst themselves
	Rules are applied in conjunction with the main METHODS rules. METHODS are treated as tie breakers.
	*/
	"CHECKING_METHODS": [
		{"key": "amount_left", "type": "ASC"},
		{"key": "category", "type": "IS NOT", "includes": ["cross-seed-links"]},
		// {"key": "PRIORITY_TAG", "type": "ASC", "prefix": "Priority - "}, // TODO:
		{"key": "state", "type": "IS", "includes": ["checkingUL"]}
	],
	/*
	Custom sort rules for torrents that are being moved
	Moving torrents are only sorted amongst themselves
	Rules are applied in conjunction with the main METHODS rules. METHODS are treated as tie breakers.
	*/
	"MOVING_METHODS": [
		{"key": "amount_left", "type": "ASC"},
		// We prefer completing existing moves to lower disk fragmentation
		{"key": "progress", "type": "DESC"}
		// { "key": "PRIORITY_TAG", "type": "ASC", "prefix": "Priority - " } // TODO:
	]
}
