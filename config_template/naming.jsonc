{
	/*
	Naming scheme for renaming torrents.
	Only applicable tags are applied. This means the same config can apply to all media types (e.g. movies without episodes work fine with `[episode]` defined).
	Names will be automatically cleaned. For example if you specify ([year]), but [year] is undefined for a torrent, the brackets around it won't be included.

	Most available tags are included in the default naming scheme with the following exceptions:
	- Use [other] if you want to capture any unmatched data in the filename
	- Use [container] if you want to capture the container (mkv, mp4, etc.)

	[!WARNING] Using minimal naming schemes increases the risk of torrent name conflicts if you download similar torrents. Consider including `[resolution]`, `[source]`, or `[group]` tags to differentiate between multiple releases of the same content.

	Examples
	Basic:
	- Schema: [title] ([year]) [resolution]
	- Output: Shrek 2 (2004) 1080p
	Balances:
	- Schema: [title] ([year]) [season][episode] [extended] [resolution] [source] [codec] [audio] [group]
	- Output: The Matrix (1999) 2160p BluRay x265 DTS-HD SPARKS
	*/
	"SCHEME": "[title] ([year]) [season][episode] - [extras] [criterion] [unrated] [extended] [uncut] [theatrical] [remastered] - [internal] [hybrid] [proper] [repack] - [[resolution] [source] [service] [downscaled] [remux] [color] [codec]] [[samplerate] [bitdepth] [audio] [channels] [language]] - [encoder] [group]",
	// Separator between different fields
	"SPACING": " ",
	/* Find and replace strings in the name
  Optionally supports regex
  */
	"REPLACE": {
		"rerip": "repack",
		"Remaster(?:ed)?": "remastered",
		"Theatrical(?:[. ]Cut)": "theatrical",
		"open(?:[\\s.]matte)?": "openmatte",
		"extended(?:[\\s.](?:cut|edition))?": "extended"
	},
	"REDUNDANT_FLAGS": {
		"codec": [
			{
				"match": ["h264", "x264"],
				"keep": "x264"
			},
			{
				"match": ["h265", "x265"],
				"keep": "x265"
			}
		],
		"audio": [
			{
				"match": ["ddp", "dd"],
				"keep": "ddp"
			}
		],
		"color": [
			{
				"match": ["DV", "HDR"],
				"keep": "DV"
			}
		],
		"resolution": [
			{
				"match": ["2160p", "4K"],
				"keep": "2160p"
			}
		]
	},
	// Fix common mistakes in group names
	"FIX_BAD_GROUPS": ["Vyndros", "t3nzin", "SiMPLE", "Silence", "RZeroX", "BluEvo"],
	// If true, will rename files based on the naming scheme
	"RENAME_FILES": true,
	// If true, will remove domain names from titles
	"REMOVE_DOMAINS": true,
	// If true, will add a tag to any torrents that had unknown metadata
	"TAG_FAILED_PARSING": true,
	// If true, will add a tag to any torrents that were successfully parsed
	"TAG_SUCCESSFUL_PARSING": false,
	// Do not rename if there are any unknown tags in the name
	"SKIP_IF_UNKNOWN": true,
	// Trim container (.mkv, .mp4, etc) from end of title
	"TRIM_CONTAINER": true,
	// List of known TLDs to remove from titles if REMOVE_DOMAINS is true
	"REMOVE_TLDS": [],
	// If true, will not include the year in season packs "Show Name S01" instead of "Show Name (2020) S01"
	"NO_YEAR_IN_SEASONS": true,
	// If true, will recheck the torrent after renaming
	"RECHECK_ON_RENAME": true,
	// If true, will force the first letter of each word to be capitalized
	"FORCE_TITLE_CASE": true,
	// Renames the directory to match the torrent name
	"FORCE_SAME_DIRECTORY_NAME": true,
	/*
	It is recommended that in qBittorrent, you configure "Copy .torrent files to:" and set the same path here.
	Torrents in this folder will be used to keep track of original filenames.
	Metadatarr will only ever read from this directory, never write to it.
	This is completely optional, but it improves rename accuracy in-case of errors caused by re-runs.
	To disable this, leave it as an empty string "".
	*/
	"TORRENTS_DIR": "",
	// Only rename if the torrents original name is known (requires TORRENTS_DIR to be set)
	"FORCE_ORIGINAL_NAME": false,
	// Tag torrents that are missing the original name (requires TORRENTS_DIR to be set)
	"TAG_MISSING_ORIGINAL_NAME": true,
	// If parsing of original name fails, reset to current name (requires TORRENTS_DIR to be true)
	"RESET_ON_FAIL": true
}
